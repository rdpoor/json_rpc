# Remote Procedure Call Proof Of Concept (rpc_poc)

This app demonstrates a simple JSON based remote procedure call architecture.

## rpc_poc01

This app runs on a SAM D21 XPRO dev board with an IO1 XPRO expansion card.
Actually, to be useful, it runs on a _pair_ of such systems.

The basic operation:
* Every second, it reads the value of the light sensor on the IO1 XPRO board.
* It transmits the light level to the "other" system via a JSON RPC message.
* When the User Button changes, it sends an RPC message to the other system.

At the same time, the system listens for incoming JSON messages:
* If it receives a "light update" message, it adjusts the brightness of the
IO1's LED via PWM.
* If it receives a "button change" message, it sets the on-board LED to
track the button state.

### Program structure

`rpc_poc1` is implemented as three FreeRTOS tasks:
* `listen_thread` waits for a newline terminated JSON message to be received
on the serial input.  It then parses the string and calls the appropriate local
function.
* `sensor_thread` runs once a second.  It uses the ADC to read the light level
on the IO1 light sensor, packages that up as a JSON string, and sends it to the
other system over the serial port.
* `button_thread` runs whenever the button changes state.  It reads the state of
the button, packages that up as a JSON string, and sends it to the other system
over the serial port.

The JSON RPC messages have the following form:
```
{"fn":"light_sensor_state", "args":[0.342]}\r\n

{"fn":"button_state", "args":[true]}\r\n

```

### Not yet implemented

This demo app shows the basic runtime structure for generating and receiving
remote procedure calls.  

It does not implement the compile-time code that parses message descriptors and
emits the C runtime code that translates C calls into JSON RPC strings and the
corresponding code that parses JSON RPC strings and calls local C function.

There are two message definitions in this demo app.

## The goal

Given a file like this:
`button_state.msgdef`

```
typedef uint32_t timestamp_t;

typedef struct {
  timestamp_t timestamp;
  bool is_pressed,
} button_state_t;

typedef struct {
  float value,
} sensor_state_t;

```

Write a tool that generates the following function declaration for the sending
side of an RPC:

`void button_state_xmt(button_state_t *button_state);`

... and the following function declaration for the "receiving" side of an RPC:

`void button_state_rcv(button_state_t *button_state);`

In between, the following JSON gets produced and sent over the wire:

`{"button_state": {"timestamp": 12345678, "is_pressed": true}}`

The tool will generate the following descriptors:

```
static const descriptor_t s_button_state_descriptor = {
  .name = "button_state",
  .rcv = button_state_rcv,
  .args = [{.name="timestamp", .type=UINT32, .offset=0},
           {.name="is_pressed", .type=BOOL, .offset=4},
           NULL],
};

static const descriptor_t s_sensor_state_descriptor = {
  .name = "sensor_state",
  .rcv = sensor_state_rcv,
  .args = [{.name="value", .type=FLOAT, .offset=0},
           NULL],
};
```

The definition of `void button_state_xmt(button_state_t *button_state)` might be
something like:

```
void button_state_xmt(button_state_t *button_state) {
  encode(s_buf,
         s_buflen,
         button_state,
         &(descriptor_t){.name="button_state",
                         .rcv=button_state_rcv,
                         .args={{.name="timestamp", .type="UINT32", .offset=0},
                                {.name="is_pressed", .type="BOOL", .offset=4},
                                NULL}});
  xmit(s_buf);
}
```

```
void rcv_thread(void) {
  while (receive(s_buf, s_buflen)) {

    if (decode(s_buf,
               s_buflen,
               &(button_state_t){},
               &(descriptor_t){.name="button_state",
                               .rcv=button_state_rcv,
                               .args={{.name="timestamp", .type="UINT32", .offset=0},
                                      {.name="is_pressed", .type="BOOL", .offset=4},
                                      NULL}})) {
        button_state_rcv(&button_state);

    } else if (rcv_type(buf, "sensor_state")) {
      if (decode(s_buf, s_buflen, &(sensor_state_t){}, ...)) {
        sensor_state_rcv(&sensor_state);
      }
    }
  }
}

Each of the
The serialized JSON generated by this message definition is:
```
{"button_state": {"timestamp": 12345678, "is_pressed": true}}
```

The serializer:
```
/**
 * @brief Serialize button state into a JSON message.
 *
 * @param buf The buffer in which to construct the JSON message.
 * @param buflen The size of buf in bytes.
 * @bool pressed The boolean pressed argument.
 *
 * @return The number of bytes that would be written to buf.  If the return
 * value exceeds buflen, then the message in buf is truncated.
 */
size_t button_state_encode(char *buf, size_t buflen, button_state_t *state);
```

The deserializer:
```
/**
 * @brief De-serialize a JSON message into a button_state_t struct.
 *
 * @param buf The buffer containing the serialized JSON string
 * @param buflen The number of bytes in the serialized JSON string
 * @param state A button_state_t struct to receive the state.
 *
 * @return true if the JSON message was successfully decoded.
 */
bool button_state_decode(const char *buf, size_t buflen, button_state_t *state);
```

#### `light_sensor_def.json`
```
{
  "msgs":[
    {
      "name":"light_sensor_state",
      "fields":[
        {
          "name":"level",
          "type":"float"
        }
      ]
    }
  ]
}
```

### Hardware / Driver notes

* [ATSAME54P20A Product Page](https://www.microchip.com/en-us/product/ATSAME54P20A)
* [SAM E54 Xplained Pro User's Guide](https://ww1.microchip.com/downloads/en/DeviceDoc/70005321A.pdf)
* [SAM D5X/E5X Family Datasheet](https://ww1.microchip.com/downloads/aemDocuments/documents/MCU32/ProductDocuments/DataSheets/SAM_D5x_E5x_Family_Data_Sheet_DS60001507G.pdf)

[I/O1 Xplained Pro](https://www.microchip.com/mymicrochip/filehandler.aspx?ddocname=en589640)

**For SAM D21**

| I/O1 | EXT1.n | SAM D21 XPRO | Function |
| --- | ------ | ------- | -------- |
| PWM LED | EXT1.7 | PB02 / TC6/WO[0] | variable LED |
| Light Sensor | EXT1.3 | PB00 / AIN[8] | Light Sensor |
| UART_RX loopback | EXT1.13 | PB09 / SERCOM4.1 | Serial RX candidate |
| UART_TX loopback | EXT1.14 | PB08 / SERCOM4.0 | Serial TX candidate |
|              |  -na-  | PB30 | On-board LED (low true) |
|              |  -na-  | PA15 | On-board button (low true, need pullup?) |
|              |  -na-  | PA23 / SERCOM3.1 | VCOM RXD |
|              |  -na-  | PA22 / SERCOM3.0 | VCOM TXD |

**For SAM E54**

| I/O1 | EXT1.n | SAM E54 XPRO | Function |
| --- | ------ | ------- | -------- |
| PWM LED | EXT1.7 | PB08 / TC4/WO[0] | variable LED |
| Light Sensor | EXT1.3 | PB04 / ADC1/AIN[6] | Light Sensor |
| UART_RX loopback | EXT1.13 | PA05 / SERCOM0.1 | Serial RX candidate |
| UART_TX loopback | EXT1.14 | PA04 / SERCOM0.0 | Serial TX candidate |
|              |  -na-  | PC18 | On-board LED (low true) |
|              |  -na-  | PB31 | On-board button (low true, need pullup) |
|              |  -na-  | PB24 / SERCOM2.1 | VCOM RXD |
|              |  -na-  | PB25 / SERCOM2.0 | VCOM TXD |

### Note to self

```
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>

typedef struct {
  char string_a[10];
  float float_a;
  int16_t int16_a;
  uint32_t uint32_a;
  uint64_t uint64_a;
  uint8_t uint8_a;
  uint8_t uint8_b;
} registry_t;

registry_t s_registry;

const char *ref_str(size_t offset) {
  return (const char *)(((char *)&s_registry) + offset);
}

float *ref_float(size_t offset) {
  return (float *)(((char *)&s_registry) + offset);
}

int16_t *ref_int16(size_t offset) {
  return (int16_t *)(((char *)&s_registry) + offset);
}

uint32_t *ref_fuint32(size_t offset) {
  return (uint32_t *)(((char *)&s_registry) + offset);
}

uint64_t *ref_uint64(size_t offset) {
  return (uint64_t *)(((char *)&s_registry) + offset);
}

uint8_t *ref_uint8(size_t offset) {
  return (uint8_t *)(((char *)&s_registry) + offset);
}

int main(void) {
  printf("s_registry at %p\n", ((char *)&s_registry));
  printf("string_a at %p\n", ref_str(offsetof(registry_t, string_a)));
  printf("float_a at %p\n", ref_str(offsetof(registry_t, float_a)));
  printf("int16_a at %p\n", ref_str(offsetof(registry_t, int16_a)));
  printf("uint32_a at %p\n", ref_str(offsetof(registry_t, uint32_a)));
  printf("uint64_a at %p\n", ref_str(offsetof(registry_t, uint64_a)));
  printf("uint8_a at %p\n", ref_str(offsetof(registry_t, uint8_a)));
  printf("uint8_b at %p\n", ref_str(offsetof(registry_t, uint8_b)));
}

s_registry at 0x404060
string_a at 0x404060
float_a at 0x40406c
int16_a at 0x404070
uint32_a at 0x404074
uint64_a at 0x404078
uint8_a at 0x404080
uint8_b at 0x404081
```
